# -*- coding: utf-8 -*-
"""LE8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ygWpchUfA1qG9IyLdCg0f0ZrV6qtvzTR
"""

# import the graph class from LE7
from LE7 import *
import heapq


# Helper function to print the distance dictionary received from dijkstra()
def printArr(dist):
	print("Vertex	Distance")
	for i in range(len(dist)):
		print(f"{i}	{dist[i]}")


def dijkstra(graph, src, dest = None):
	# your code here
	if src not in graph.graph:
		return None

	# Initialize the distances dictionary with infinite distances and zero for the source node
	distances = {node: float('infinity') for node in graph.graph}
	distances[src] = 0

	# Priority queue to select the node with the smallest distance
	priority_queue = [(0, src)]

	# Set to keep track of visited nodes
	visited = set()

	while priority_queue:
			current_distance, current_node = heapq.heappop(priority_queue)

			# If the node has been visited, skip it
			if current_node in visited:
					continue

			visited.add(current_node)

			# Explore neighbors
			for neighbor, weight in graph.graph[current_node]:
					distance = current_distance + weight

					# If the calculated distance is less than the known distance, update the distance
					if distance < distances[neighbor]:
							distances[neighbor] = distance
							heapq.heappush(priority_queue, (distance, neighbor))

	# If a destination is specified, return only the distance to that node
	if dest is not None:
			return distances.get(dest, None)

	return distances

	if dest == None:
			return distances
	return distances[dest]


def primMST(graph, src):
	# your code here
	if src not in graph.graph or not graph.graph:
		return None

	# Priority queue to select the edge with the smallest weight
	priority_queue = [(0, src, src)]  # (weight, src, dest)

	# Set to keep track of visited nodes
	visited = set()

	# Store the MST edges and the total cost
	mst_edges = []
	total_cost = 0

	while priority_queue and len(visited) < graph.getVertexCount():
			weight, _, dest = heapq.heappop(priority_queue)

			# If the node has been visited, skip it
			if dest in visited:
					continue

			visited.add(dest)
			mst_edges.append((src, dest, weight))
			total_cost += weight

			# Explore the neighbors of the current node
			for neighbor, weight in graph.graph[dest]:
					if neighbor not in visited:
							heapq.heappush(priority_queue, (weight, dest, neighbor))

	return total_cost

if __name__ == "__main__":
    # Driver program to test the above functions
    graph = Graph(9)
    graph.addEdge(0, 1, 4)
    graph.addEdge(0, 7, 3)
    graph.addEdge(1, 2, 5)
    graph.addEdge(1, 7, 11)
    graph.addEdge(2, 3, 12)
    graph.addEdge(2, 8, 2)
    graph.addEdge(2, 5, 8)
    graph.addEdge(3, 4, 9)
    graph.addEdge(3, 5, 14)
    graph.addEdge(4, 5, 10)
    graph.addEdge(5, 6, 13)
    graph.addEdge(6, 7, 1)
    graph.addEdge(6, 8, 6)
    graph.addEdge(7, 8, 7)

    print("Graph:")
    graph.printGraph()
    print()
    src = 0
    dist = dijkstra(graph, src)
    print(f"Source vertex: {src}")
    print(dist)
    print()
    printArr(dist)
    print()
    dest = 8
    print(f"Shortest distance from {src} to {dest}: {dijkstra(graph, 0, dest)}")
    print()
    print(f"Cost of MST traversal from vertex {1}: {primMST(graph, 1)}")